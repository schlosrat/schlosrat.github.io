// Decompiled with JetBrains decompiler
// Type: KSP.Sim.impl.OrbiterComponent
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EF61A348-EB87-4C99-B6BD-CBCF875CC384
// Assembly location: C:\KSP2\DLL_min\Assembly-CSharp.dll
// XML documentation location: C:\KSP2\DLL_min\Assembly-CSharp.xml

using KSP.Api;
using KSP.Sim.Converters;
using KSP.Sim.Definitions;
using KSP.Sim.State;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace KSP.Sim.impl
{
  public class OrbiterComponent : ObjectComponent, IPositionDriver, ILinearMotionDriver
  {
    public const int MAX_NBODY_ORBITS = 10;
    private double _lastKnownPeriapsis;
    private double _warpCollisionRecalculateThreshhold;
    private double _collisionUT;
    private bool _isConverged;
    private bool _collisionPathNotified;
    private bool isStable;
    private IUniverseModel universeModel;

    [TypeConverterIgnore]
    public override System.Type Type
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    [TypeConverterIgnore]
    public override System.Type DefinitionType
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    [TypeConverterIgnore]
    public override System.Type StateType
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    public Color orbitColor
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] private set => throw null;
    }

    public Color nodeColor
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] private set => throw null;
    }

    public float lowerCamVsSmaRatio
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] private set => throw null;
    }

    public float upperCamVsSmaRatio
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] private set => throw null;
    }

    /// <summary>
    /// The current patch for this OrbiterComponent.
    /// </summary>
    [TypeConverterIgnore]
    public PatchedConicsOrbit PatchedConicsOrbit
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>
    /// The list of patches generated by ManeuverPlanSolver.
    /// </summary>
    [TypeConverterIgnore]
    public List<PatchedNBodyOrbit> PatchedNBodyOrbits
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>
    /// The current patch for this OrbiterComponent.
    /// </summary>
    [TypeConverterIgnore]
    public IPatchedOrbit PatchedOrbit
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] set => throw null;
    }

    /// <summary>
    /// The reverse flag for this OrbiterComponent. If true, the orbit progresses retrograde?
    /// </summary>
    [TypeConverterIgnore]
    public bool reverse
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>
    /// The action triggered when this OrbiterComponent's state has been updated. See UpdatePosition, UpdateVelocity, and UpdateFromStateVectors.
    /// </summary>
    public event Action<IKeplerOrbit> OrbitalStateUpdated
    {
      [MethodImpl(MethodImplOptions.NoInlining)] add => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] remove => throw null;
    }

    /// <summary>
    /// The action triggered when the reference body changes, e.g. when transitioning across an SOI boundary.
    /// </summary>
    public event Action<OrbiterComponent, CelestialBodyComponent> OnReferenceBodyChange
    {
      [MethodImpl(MethodImplOptions.NoInlining)] add => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] remove => throw null;
    }

    /// <summary>
    /// The PatchedConicSolver for this OrbiterComponent.
    /// </summary>
    [TypeConverterIgnore]
    public PatchedConicSolver PatchedConicSolver
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] set => throw null;
    }

    /// <summary>
    /// The ManeuverPlanSolver for this OrbiterComponent.
    /// </summary>
    [TypeConverterIgnore]
    public ManeuverPlanSolver ManeuverPlanSolver
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] set => throw null;
    }

    /// <summary>
    /// The OrbitTargeter for this OrbiterComponent.
    /// </summary>
    [TypeConverterIgnore]
    public OrbitTargeter OrbitTargeter
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] set => throw null;
    }

    /// <summary>
    /// The coordinate system for this OrbiterComponent.
    /// </summary>
    [TypeConverterIgnore]
    public ICoordinateSystem coordinateSystem
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>
    /// The current local position for this OrbiterComponent.
    /// </summary>
    [TypeConverterIgnore]
    public Vector3d localPosition
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }


    /// <summary>
    /// The current relative motion for this OrbiterComponent.
    /// </summary>
    [TypeConverterIgnore]
    public IMotion relativeToMotion
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>
    /// The current relative velocity for this OrbiterComponent.
    /// </summary>
    [TypeConverterIgnore]
    public Vector relativeVelocity
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>
    /// The Position structure for this OrbiterComponent.
    /// </summary>
    [TypeConverterIgnore]
    public Position Position
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>
    /// Updates the Position structure for this OrbiterComponent. To update both position and velocity use UpdateFromStateVectors.
    /// </summary>
    /// <param name="newPosition"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void UpdatePosition(Position newPosition) => throw null;

    /// <summary>
    /// The action triggered when the position is updated.
    /// </summary>
    public event Action<Position> PositionUpdated
    {
      [MethodImpl(MethodImplOptions.NoInlining)] add => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] remove => throw null;
    }

    /// <summary>
    /// The Velocity structure for this OrbiterComponent.
    /// </summary>
    [TypeConverterIgnore]
    public Velocity Velocity
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>
    /// Updates the Velocity structure for this OrbiterComponent. To update both position and velocity use UpdateFromStateVectors
    /// </summary>
    /// <param name="newVelocity"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void UpdateVelocity(Velocity newVelocity) => throw null;

    /// <summary>
    /// The action triggered when the velocity is updated
    /// </summary>
    public event Action<Velocity> VelocityUpdated
    {
      [MethodImpl(MethodImplOptions.NoInlining)] add => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] remove => throw null;
    }

    /// <summary>
    /// Updates both the Position structure and Velocity structure for this OrbiterComponent. To update only position or velocity use either UpdatePosition or UpdateVelocity respectively.
    /// </summary>
    /// <param name="newPosition"></param>
    /// <param name="newVelocity"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void UpdateFromStateVectors(Position newPosition, Velocity newVelocity) => throw null;

    /// <summary>
    /// Configures a (new) (blank?) OrbiterComponent.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public OrbiterComponent() => throw null;

    /// <summary>
    /// Configures a (new) OrbiterComponent using the supplied universeModel.
    /// </summary>
    /// <param name="universeModel"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public OrbiterComponent(UniverseModel universeModel) => throw null;

    /// <summary>
    /// Configures a (new) OrbiterComponent using the supplied orbiterDefinition and universeModel.
    /// </summary>
    /// <param name="orbiterDefinition"></param>
    /// <param name="universeModel"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public OrbiterComponent(OrbiterDefinition orbiterDefinition, IUniverseModel universeModel) => throw null;

    /// <summary>
    /// Returns the orbiterDefinition object for this OrbiterComponent.
    /// </summary>
    /// <returns orbiterDefinition></returns>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override object GetDefinition() => throw null;

    /// <summary>
    /// Returns the stateData object for this OrbiterComponent.
    /// </summary>
    /// <returns stateData></returns>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override object GetState() => throw null;

    /// <summary>
    /// Validates the stateData for this OrbiterComponent using the supplied simulationModelMap. Returns true if valid and false otherwise.
    /// </summary>
    /// <param name="stateData"></param>
    /// <param name="simulationModelMap"></param>
    /// <returns pass></returns>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override bool ValidateState(object stateData, ISimulationModelMap simulationModelMap) => throw null;

    /// <summary>
    /// Sets the stateData for this OrbiterComponent using the supplied simulationModelMap. Returns true if the state was successfulle set and false otherwise.
    /// </summary>
    /// <param name="stateData"></param>
    /// <param name="simulationModelMap"></param>
    /// <returns pass></returns>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override object SetState(object stateData, ISimulationModelMap simulationModelMap) => throw null;

    /// <summary>
    /// Sets the stateData for this OrbiterComponent using the supplied KeplerOrbitState, universalTime, and simulationModelMap.
    /// </summary>
    /// <param name="state"></param>
    /// <param name="universalTime"></param>
    /// <param name="simulationModelMap"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void SetState(
      KeplerOrbitState state,
      double universalTime,
      ISimulationModelMap simulationModelMap)
    {
      throw null;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="universalTime"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override void OnStart(double universalTime) => throw null;

    /// <summary>
    /// 
    /// </summary>
    /// <param name="simObject"></param>
    /// <param name="universalTime"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override void OnRemoved(SimulationObjectModel simObject, double universalTime) => throw null;

    /// <summary>
    /// 
    /// </summary>
    /// <param name="universalTime"></param>
    /// <param name="deltaUniversalTime"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override void OnFixedUpdate(double universalTime, double deltaUniversalTime) => throw null;

    /// <summary>
    /// Updates this OrbiterComponent from parameters at the supplied universalTime? Confirm and update documentation as needed.
    /// </summary>
    /// <param name="universalTime"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void UpdateFromParameters(double universalTime) => throw null;

    /// <summary>
    /// Checks the orbital stability for this OrbiterComponent.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void CheckOrbitStability() => throw null;

    /// <summary>
    /// Checks for object collisions (for?/with?) inactive vessel(s?). Confirm and update documentation please.
    /// </summary>
    /// <param name="collisionTolerance"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void CheckInactiveVesselCollision(double collisionTolerance) => throw null;

    /// <summary>
    /// No clue. Please investigate and update
    /// </summary>
    /// <param name="patch"></param>
    /// <param name="collisionTolerance"></param>
    /// <param name="referenceBodyHeight"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void onRailsCollision(
      PatchedConicsOrbit patch,
      double collisionTolerance,
      double referenceBodyHeight)
    {
      throw null;
    }
  }
}
